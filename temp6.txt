    }

    const rowsParsed = rowsFromTable(tbl);
    const rows = Array.isArray(rowsParsed) ? rowsParsed : [];
    const rowsLen = rows.length|0;

    // with direct, guaranteed assignments:
    predRowsMut.value   = rows;
    latestRowsMut.value = rows;

    updateDownload(rows);
    setStatus(`Done â€” ${rowsLen} rows.`, { ok:true });
    downloadBtn.disabled = rowsLen === 0;

    // Update selector (this calls setOptions â†’ onChange, which will re-render)
    refreshHeatLenChoices();

    // Ensure we render even if setOptions didnâ€™t fire (e.g., identical value)
    const safeLen = Number(heatLenCtrl.value);
    if (rowsLen) {
      renderHeatmap(rows, safeLen);
      const seqNow = selectedSeqIndex();
      try {
        const selAllele = (selectedAlleleMut && "value" in selectedAlleleMut) ? selectedAlleleMut.value : null;
        renderPeptideTrack(seqNow, safeLen, selAllele);
        updatePeptideDownloadForSeq(seqNow);
      } catch {}
      try {
        const selAllele = (selectedAlleleMut && "value" in selectedAlleleMut) ? selectedAlleleMut.value : null;
        renderPeptideAlleleTrack(seqNow, safeLen, selAllele);
      } catch {}
    }

  } catch (err) {
    setStatus(`Error: ${err?.message || err}`, { warn:true });
  } finally {
    runBtn.disabled = false;
  }
});

```

```js
/* Safe setter for Mutables (permissive) */
function setMut(mut, val) {
  if (!mut || (typeof mut !== "object" && typeof mut !== "function")) {
    return;
  }
  try {
    // Create or overwrite .value unconditionally
    mut.value = val;
  } catch (e) {
    // Fallback in very strict proxies
    try {
      Object.defineProperty(mut, "value", { value: val, writable: true, configurable: true });
    } catch (e2) {
      // quiet fail
    }
  }
}

```

```js
/* â”€â”€ Heatmap length selector (adaptive to slider + data) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const heatLenSlot = html`<div></div>`;

function makeHeatLenSelect({ onChange } = {}) {
  const root = document.createElement("div");
  root.style.fontFamily = "'Roboto', sans-serif";

  const label = document.createElement("label");
  label.textContent = "Heatmap length";
  label.style.cssText = "display:block;margin:0 0 8px 0;font:500 13px/1.3 'Roboto',sans-serif;color:#111;";

  const sel = document.createElement("select");
  sel.style.cssText = `
    display:block; width:100%; min-width:160px;
    padding:8px 10px; border:1px solid #bbb; border-radius:6px; background:#fff;
    font:500 14px/1.2 'Roboto',sans-serif; color:#006DAE; cursor:pointer;
  `;

  root.append(label, sel);

  Object.defineProperty(root, "value", {
    get(){ return sel.value ? Number(sel.value) : undefined; },
    set(v){ sel.value = String(v); }
  });

  // Only updates options; does NOT auto-fire any events anymore.
  root.setOptions = (lengths = [], { prefer } = {}) => {
    const before = Array.from(sel.querySelectorAll("option")).map(o => +o.value);
    const old = String(sel.value);

    sel.replaceChildren();
    for (const n of lengths) {
      const opt = document.createElement("option");
      opt.value = String(n);
      opt.textContent = String(n);
      sel.appendChild(opt);
    }
    if (prefer != null && lengths.includes(prefer)) sel.value = String(prefer);
    else if (lengths.length) sel.value = lengths.includes(+old) ? old : String(lengths[0]);
  };

  const handle = () => {
    const len = Number(root.value);
    const rowsNow = latestRowsMut.value || [];
    if (typeof onChange === "function") onChange(len);
  };
  sel.addEventListener("input", handle); // ðŸ”¸ only one event

  return root;
}

// from slider â†’ continuous [a..b]
function sliderLengths() {
  const v = Array.isArray(lengthCtrl?.value) ? lengthCtrl.value : [9, 9];
  const a = Math.min(...v), b = Math.max(...v);
  const out = [];
  for (let n = a; n <= b; n++) out.push(n);
  return out;
}
function intersectSorted(a, b) { const B = new Set(b); return a.filter(x => B.has(x)); }

const heatLenCtrl = makeHeatLenSelect({
  onChange: (len) => {
    const rowsNow = (latestRowsMut.value && latestRowsMut.value.length) ? latestRowsMut.value
                  : (Array.isArray(predRowsMut.value) ? predRowsMut.value : []);
    if (!rowsNow.length) return;

    const seqNow = selectedSeqIndex();
    renderHeatmap(rowsNow, Number(len), seqNow);

    // keep peptide track/download in sync
    try {
      const selAllele = (selectedAlleleMut && "value" in selectedAlleleMut) ? selectedAlleleMut.value : null;
      renderPeptideTrack(seqNow, Number(len), selAllele);
      updatePeptideDownloadForSeq(seqNow);
    } catch {}
    try {
      const selAllele = (selectedAlleleMut && "value" in selectedAlleleMut) ? selectedAlleleMut.value : null;
      renderPeptideAlleleTrack(seqNow, Number(len), selAllele);
    } catch {}
  }
});


heatLenSlot.replaceChildren(heatLenCtrl);

function refreshHeatLenChoices(seqOverride) {
  const fromSlider = sliderLengths();
  const rowsForLens = (latestRowsMut.value && latestRowsMut.value.length)
    ? latestRowsMut.value
    : (Array.isArray(predRowsMut.value) ? predRowsMut.value : []);

  const seqIdx = Number.isFinite(seqOverride) ? seqOverride : selectedSeqIndex();

  const fromData = lengthsFromRowsForSeq(rowsForLens, seqIdx);
  const lens     = fromData.length ? intersectSorted(fromSlider, fromData) : fromSlider;
  const prefer   = heatLenCtrl.value ?? lens[0];
