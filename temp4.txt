  placeholder: 
`e.g.
ALHLLLEVE
EQITFMQAL
EQLGQKFEE
FQDILLRMS
HSLQNRNEK
IEEVRHKLK
KLKITENSF
KLYRDSLGE
KMQLESSSE
KWREQLGQK
LESSSEDLN
LEVEQEIRT
LKLYRDSLG
NRNEKWREQ
NSFEQITFM
NTVSSFQDI`
});

const DEBOUNCE_PEP_MS = 350;
let pepDebounceTimer = null;

async function parseAndApplyPeptides(rawText) {
  const list = parsePeptideInput(rawText).slice(0, 100); // cap ~100 as requested
  setMut(peptideTextMut, rawText);
  setMut(peptideListMut, list);

  // Re-align against all sequences
  const aligned = alignAllPeptides(seqListMut.value || [], list);
  alignedPepsMut.value = aligned;
  latestAlignedPepsMut.value = aligned;

  // Refresh track & download for current selection
  {
    const seqNow = selectedSeqIndex();
    const lenNow = Number(heatLenCtrl?.value);
    const selAllele = (selectedAlleleMut && "value" in selectedAlleleMut) ? selectedAlleleMut.value : null;
    renderPeptideTrack(seqNow, lenNow, selAllele);
  }
  updatePeptideDownloadForSeq(selectedSeqIndex());
}

const onPeptideInput = () => {
  if (peptideBox.__isProg()) return;
  clearTimeout(pepDebounceTimer);
  pepDebounceTimer = setTimeout(() => {
    parseAndApplyPeptides(peptideBox.value);
  }, DEBOUNCE_PEP_MS);
};
peptideBox.textarea.addEventListener("input", onPeptideInput);
invalidation.then(() => peptideBox.textarea.removeEventListener("input", onPeptideInput));

/* Upload wiring (mirror sequences) */
{
  const isFileLike = (f) => f && typeof f.text === "function";
  const processFile = async (file) => {
    if (!isFileLike(file)) {
      peptideBox.setText("");
      setMut(peptideListMut, []);
      setMut(peptideTextMut, "");
      alignedPepsMut.value = [];
      latestAlignedPepsMut.value = [];
      {
        const seqNow = selectedSeqIndex();
        const lenNow = Number(heatLenCtrl?.value);
        const selAllele = (selectedAlleleMut && "value" in selectedAlleleMut) ? selectedAlleleMut.value : null;
        renderPeptideTrack(seqNow, lenNow, selAllele);
      }
      updatePeptideDownloadForSeq(selectedSeqIndex());
      return;
    }
    let txt = ""; try { txt = await file.text(); } catch {}
    peptideBox.setText(txt);
    await parseAndApplyPeptides(txt);
  };

  const onRootInput = async () => {
    const v = uploadPepsBtn?.value;
    const file = Array.isArray(v) ? v[0] : v;
    await processFile(file ?? null);
  };
  uploadPepsBtn.addEventListener("input", onRootInput);

  const fileEl = uploadPepsBtn?.querySelector?.('input[type="file"]');
  const onFileChange = async () => { await processFile(fileEl?.files?.[0] ?? null); };
  fileEl?.addEventListener("change", onFileChange);

  if (fileEl?.files?.length) onFileChange();

  invalidation.then(() => {
    uploadPepsBtn.removeEventListener("input", onRootInput);
    fileEl?.removeEventListener("change", onFileChange);
  });
}

```

```js
const peptideSlot = html`<div style="margin:0"></div>`;
const dlPepsBtn   = makeButton("Download peptides (CSV)");
dlPepsBtn.disabled = true;

/* Filter aligned rows for a given seq index */
function alignedForSeq(idx) {
  const all = Array.isArray(latestAlignedPepsMut.value) && latestAlignedPepsMut.value.length
              ? latestAlignedPepsMut.value
              : Array.isArray(alignedPepsMut.value) ? alignedPepsMut.value : [];
  return all.filter(r => r.seq_index === idx);
}

/* Render track for current sequence; keep axis extent in sync with heatmap. */
function renderPeptideTrack(seqIdx, lenNow, selAllele = null) {
 // Default to globally selected allele if not provided (no heatmapSlot reads)
 if (selAllele == null) {
   try {
     selAllele = (selectedAlleleMut && "value" in selectedAlleleMut) ? selectedAlleleMut.value : null;
   } catch { selAllele = null; }
 }
  const aligned = alignedForSeq(seqIdx);
  const rows = aligned
    .filter(r => !Number.isFinite(lenNow) || Number(r.length) === lenNow)
    .map(r => ({ start: r.start, length: r.length, peptide: r.peptide }));
  const posExtent = getAxisExtentForSeq(seqIdx);

  peptideSlot.replaceChildren();
  if (!rows.length) {
    const em = document.createElement("em");
    em.textContent = "No aligned peptides for the selected sequence and length.";
    peptideSlot.appendChild(em);
    return;
  }
  // Build percentile map for colouring
  // - If an allele is selected, color by that allele's percentiles
  // - Otherwise, use the minimum percentile across alleles
  let pctMap = new Map();
  try {
    const rowsPred = (latestRowsMut.value && latestRowsMut.value.length)
      ? latestRowsMut.value
      : (Array.isArray(predRowsMut.value) ? predRowsMut.value : []);
    const method = getPredictor().id;
    const r1 = rowsPred.filter(r => {
      const okSeq = Number(r["seq #"] ?? r["sequence_number"] ?? 1) === Number(seqIdx);
      if (!okSeq) return false;
      if (!Number.isFinite(lenNow)) return true;
      const okLen = rowLen(r) === Number(lenNow);
      if (!okLen) return false;
      if (selAllele) return String(r?.allele || "") === String(selAllele);
      return true;
    });
    const pctKey = r1.length ? pickPercentileKey(method, r1[0]) : null;
    if (pctKey) {
      const tmp = new Map();
      for (const r of r1) {
        const pep = String(r.peptide || "").toUpperCase().replace(/-/g,"").trim();
        const v = Number(r[pctKey]);
        if (!pep || !Number.isFinite(v)) continue;
        if (selAllele) {
          // direct mapping for selected allele
          tmp.set(pep, v);
        } else {
