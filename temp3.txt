    if (!tbl || !Array.isArray(tbl.table_data) || !Array.isArray(tbl.table_columns)) {
      return [];
    }
    const keys = tbl.table_columns.map(c => c?.display_name ?? c?.name ?? "");
    // Accept both array-of-arrays and array-of-objects
    const out = tbl.table_data.map(row => {
      if (Array.isArray(row)) {
        return Object.fromEntries(row.map((v, i) => [keys[i] || `col_${i}`, v]));
      }
      if (row && typeof row === "object") {
        // Already an object: keep as-is
        return row;
      }
      // Fallback: wrap scalar
      return { value: row };
    });
    return out;
  } catch (e) {
    return [];
  }
}


/* FASTA getter â€“ use cached text if present, otherwise read from current file */
async function getLatestFastaText() {
  // 1) Cached sanitized FASTA from prior parse
  const cached = (fastaTextMut && typeof fastaTextMut === "object" && "value" in fastaTextMut)
    ? String(fastaTextMut.value || "").trim()
    : "";
  if (cached) return cached;

  // 2) User may have pasted into the textarea but debounce hasn't fired yet
  const raw = String(fastaBox?.value || "").trim();
  if (raw) {
    try {
      // Parse now to produce sanitized FASTA and sync state
      await parseAndApplyFASTA(raw);
      const after = String((fastaTextMut?.value ?? "")).trim();
      if (after) return after;
    } catch {}
  }

  // 3) Fall back to reading from the uploaded file, if any
  const tryRead = async (file) => {
    if (!file || typeof file.text !== "function") return "";
    let t = ""; try { t = await file.text(); } catch {}
    const { fastaText } = parseFastaForIEDB(t, { wrap:false });
    return (fastaText || "").trim();
  };

  const v = uploadSeqBtn?.value;
  const file1 = Array.isArray(v) ? v[0] : v;
  let fasta = await tryRead(file1);
  if (!fasta) {
    const fileEl = uploadSeqBtn?.querySelector?.('input[type="file"]');
    fasta = await tryRead(fileEl?.files?.[0]);
  }
  if (fasta) {
    setMut(fastaTextMut, fasta);
    return fasta;
  }

  // 4) Final fallback: rebuild from parsed sequences if available
  try {
    const seqs = Array.isArray(seqListMut?.value) ? seqListMut.value : [];
    if (seqs.length) {
      const rebuilt = seqs
        .map(({ id, sequence }) => `>${id}\n${String(sequence ?? "")}`)
        .join("\n")
        .trim();
      if (rebuilt) {
