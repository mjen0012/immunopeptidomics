function lengthsFromRows(rows) {
  const set = new Set();
  for (const r of rows || []) {
    const seqNum = Number(r["seq #"] ?? r["sequence_number"] ?? 1);
    if (seqNum !== 1) continue;
    const L = rowLen(r);
    if (Number.isFinite(L)) set.add(L);
  }
  return [...set].sort((a,b)=>a-b);
}

```


```js
/* ── Heatmap prep + render (no SQL) ─────────────────────────────── */

const heatmapSlot = html`<div style="margin:0"></div>`;

function buildHeatmapData(rows, method, lengthFilter, seqIdx) {
  const wantedLen = Number(lengthFilter);
  const wantSeq   = Number(seqIdx);
  const r1 = rows.filter(r => {
    const seqNum = Number(r["seq #"] ?? r["sequence_number"] ?? 1);
    return seqNum === wantSeq && rowLen(r) === wantedLen;
  });

  if (!r1.length) return { cells: [], posExtent: [1, 1], alleles: [] };

  const pctKey = pickPercentileKey(method, r1[0]);
  if (!pctKey) return { cells: [], posExtent: [1, 1], alleles: [] };

  const byAllelePos = new Map();   // key: `${allele}|${pos}`
  let posMax = 1;
  const alleleSet = new Set();

  for (const row of r1) {
    const allele  = row["allele"];
    const peptide = row["peptide"];
    const start   = +row["start"];
    const end     = +row["end"];
    const pct     = Number(row[pctKey]);
    if (!allele || !peptide || !Number.isFinite(start) || !Number.isFinite(end) || !Number.isFinite(pct)) continue;
    if (end > posMax) posMax = end;
    alleleSet.add(allele);

    for (let pos = start; pos <= end; pos++) {
      const k = `${allele}|${pos}`;
      const aaIdx = pos - start;
      const aa    = peptide.charAt(aaIdx) || "";
      const prev  = byAllelePos.get(k);
      if (!prev || pct < prev.pct) byAllelePos.set(k, { allele, pos, pct, peptide, aa });
    }
  }

  const cells = Array.from(byAllelePos.values())
    .sort((a,b) => a.allele.localeCompare(b.allele) || a.pos - b.pos);

  return { cells, posExtent: [1, posMax], alleles: [...alleleSet].sort() };
}

let HM_RENDER_COUNT = 0;

function renderHeatmap(rows, lengthFilter, seqIdx = selectedSeqIndex()) {
  try {
    const rowsArr = Array.isArray(rows) ? rows : [];
    if (!rowsArr.length) {
      heatmapSlot.replaceChildren(Object.assign(document.createElement("em"), {textContent:"No heat-map data — empty rows."}));
      return;
    }

    const { id: method } = getPredictor();

    // before choosing first row when length is missing, prefer the passed seqIdx
    let wantedLen = Number(lengthFilter);
    if (!Number.isFinite(wantedLen)) {
      const wantSeq = Number.isFinite(seqIdx) ? seqIdx : selectedSeqIndex(); // ✅ prefer param
      const first = rowsArr.find(r => Number(r["seq #"] ?? r["sequence_number"] ?? 1) === wantSeq);
      wantedLen = rowLen(first);
    }

    const tStart = performance.now();
    const { cells, posExtent, alleles } =
      buildHeatmapData(rowsArr, method, wantedLen, seqIdx);
    // cache the latest heatmap extent for this sequence (used by peptide tracks)
    __posExtentBySeq.set(Number(seqIdx), posExtent);

    HM_RENDER_COUNT++;
    heatmapSlot.dataset.renderCount  = String(HM_RENDER_COUNT);
    heatmapSlot.dataset.lastLen      = String(wantedLen);
    heatmapSlot.dataset.lastMethod   = String(method);
    heatmapSlot.dataset.cellCount    = String(cells?.length ?? 0);
    heatmapSlot.dataset.alleleCount  = String(alleles?.length ?? 0);
    heatmapSlot.dataset.posMin       = String(posExtent?.[0] ?? "");
    heatmapSlot.dataset.posMax       = String(posExtent?.[1] ?? "");

    heatmapSlot.replaceChildren();
    if (!Array.isArray(cells) || !cells.length) {
      const span = document.createElement("span");
      span.textContent = "No heat-map data for selected length.";
      span.style.fontStyle = "italic";
      heatmapSlot.appendChild(span);
      return;
    }

    const el = heatmapChart({
      data: cells,
      posExtent,
      cellHeight: 18,
      sizeFactor: 1.1,
      onReady: (xBase) => {
        // scale available if needed later
      },
      onZoom: (zx, t) => {
        __zoomSync.transform = t;
        const p = __zoomSync.peptideEl;
        const a = __zoomSync.pepAllele;
        if (p && typeof p.__setZoom === "function") p.__setZoom(t);
        if (a && typeof a.__setZoom === "function") a.__setZoom(t);
      },
      onRowToggle: (allele) => {
        // store selection (defensively avoid null Mutable)
        try {
          if (selectedAlleleMut && typeof selectedAlleleMut === "object" && ("value" in selectedAlleleMut)) {
            selectedAlleleMut.value = allele || null;
          }
        } catch {}
        try { if (heatmapSlot && heatmapSlot.dataset) heatmapSlot.dataset.selectedAllele = String(allele || ""); } catch {}
        const wantSeq = Number.isFinite(seqIdx) ? seqIdx : selectedSeqIndex();
        // Avoid reactive cycle: derive length from the heatmap element itself
        const wantLen = Number(el?.dataset?.len);
        try { renderPeptideAlleleTrack(wantSeq, wantLen, allele || null); } catch {}
        // Also update the peptideChartScan coloring to reflect selected allele
        try { renderPeptideTrack(wantSeq, wantLen, allele || null); } catch {}
      }
    });

    el.dataset.len    = String(wantedLen);
    el.dataset.method = String(method);
    el.dataset.cells  = String(cells.length);
    el.dataset.alleles= String(alleles.length);

    heatmapSlot.appendChild(el);
    __zoomSync.heatmapEl = el;
    if (__zoomSync.transform && typeof el.__setZoom === "function") {
      el.__setZoom(__zoomSync.transform);
    }

  } catch (err) {
    const span = document.createElement("span");
    span.textContent = `Heatmap error: ${err?.message || err}`;
    span.style.color = "#B30000";
    heatmapSlot.replaceChildren(span);
  }
}

```
