
  // Re-align against all sequences
  const aligned = alignAllPeptides(seqListMut.value || [], list);
  alignedPepsMut.value = aligned;
  latestAlignedPepsMut.value = aligned;

  // Refresh track & download for current selection
  {
    const seqNow = selectedSeqIndex();
    const lenNow = Number(heatLenCtrl?.value);
    const selAllele = (selectedAlleleMut && "value" in selectedAlleleMut) ? selectedAlleleMut.value : null;
    renderPeptideTrack(seqNow, lenNow, selAllele);
  }
  updatePeptideDownloadForSeq(selectedSeqIndex());
}

const onPeptideInput = () => {
  if (peptideBox.__isProg()) return;
  clearTimeout(pepDebounceTimer);
  pepDebounceTimer = setTimeout(() => {
    parseAndApplyPeptides(peptideBox.value);
  }, DEBOUNCE_PEP_MS);
};
peptideBox.textarea.addEventListener("input", onPeptideInput);
invalidation.then(() => peptideBox.textarea.removeEventListener("input", onPeptideInput));

/* Upload wiring (mirror sequences) */
{
  const isFileLike = (f) => f && typeof f.text === "function";
  const processFile = async (file) => {
    if (!isFileLike(file)) {
      peptideBox.setText("");
      setMut(peptideListMut, []);
      setMut(peptideTextMut, "");
      alignedPepsMut.value = [];
      latestAlignedPepsMut.value = [];
      {
        const seqNow = selectedSeqIndex();
        const lenNow = Number(heatLenCtrl?.value);
        const selAllele = (selectedAlleleMut && "value" in selectedAlleleMut) ? selectedAlleleMut.value : null;
        renderPeptideTrack(seqNow, lenNow, selAllele);
      }
      updatePeptideDownloadForSeq(selectedSeqIndex());
      return;
    }
    let txt = ""; try { txt = await file.text(); } catch {}
    peptideBox.setText(txt);
    await parseAndApplyPeptides(txt);
  };

  const onRootInput = async () => {
    const v = uploadPepsBtn?.value;
    const file = Array.isArray(v) ? v[0] : v;
    await processFile(file ?? null);
  };
  uploadPepsBtn.addEventListener("input", onRootInput);

  const fileEl = uploadPepsBtn?.querySelector?.('input[type="file"]');
  const onFileChange = async () => { await processFile(fileEl?.files?.[0] ?? null); };
  fileEl?.addEventListener("change", onFileChange);

  if (fileEl?.files?.length) onFileChange();

  invalidation.then(() => {
    uploadPepsBtn.removeEventListener("input", onRootInput);
    fileEl?.removeEventListener("change", onFileChange);
  });
}

```

```js
const peptideSlot = html`<div style="margin:0"></div>`;
const dlPepsBtn   = makeButton("Download peptides (CSV)");
dlPepsBtn.disabled = true;

/* Filter aligned rows for a given seq index */
function alignedForSeq(idx) {
  const all = Array.isArray(latestAlignedPepsMut.value) && latestAlignedPepsMut.value.length
              ? latestAlignedPepsMut.value
              : Array.isArray(alignedPepsMut.value) ? alignedPepsMut.value : [];
  return all.filter(r => r.seq_index === idx);
}

/* Render track for current sequence; keep axis extent in sync with heatmap. */
function renderPeptideTrack(seqIdx, lenNow, selAllele = null) {
 // Default to globally selected allele if not provided (no heatmapSlot reads)
 if (selAllele == null) {
   try {
     selAllele = (selectedAlleleMut && "value" in selectedAlleleMut) ? selectedAlleleMut.value : null;
   } catch { selAllele = null; }
 }
  const aligned = alignedForSeq(seqIdx);
  const rows = aligned
    .filter(r => !Number.isFinite(lenNow) || Number(r.length) === lenNow)
    .map(r => ({ start: r.start, length: r.length, peptide: r.peptide }));
  const posExtent = getAxisExtentForSeq(seqIdx);

  peptideSlot.replaceChildren();
  if (!rows.length) {
    const em = document.createElement("em");
    em.textContent = "No aligned peptides for the selected sequence and length.";
    peptideSlot.appendChild(em);
    try { updateChartDlButtons(); } catch {}
    return;
  }
  // Build percentile map for colouring
  // - If an allele is selected, color by that allele's percentiles
  // - Otherwise, use the minimum percentile across alleles
  let pctMap = new Map();
  try {
    const rowsPred = (latestRowsMut.value && latestRowsMut.value.length)
      ? latestRowsMut.value
      : (Array.isArray(predRowsMut.value) ? predRowsMut.value : []);
    const method = getPredictor().id;
    const r1 = rowsPred.filter(r => {
      const okSeq = Number(r["seq #"] ?? r["sequence_number"] ?? 1) === Number(seqIdx);
      if (!okSeq) return false;
      if (!Number.isFinite(lenNow)) return true;
      const okLen = rowLen(r) === Number(lenNow);
      if (!okLen) return false;
      if (selAllele) return String(r?.allele || "") === String(selAllele);
      return true;
    });
    const pctKey = r1.length ? pickPercentileKey(method, r1[0]) : null;
    if (pctKey) {
      const tmp = new Map();
      for (const r of r1) {
        const pep = String(r.peptide || "").toUpperCase().replace(/-/g,"").trim();
        const v = Number(r[pctKey]);
        if (!pep || !Number.isFinite(v)) continue;
        if (selAllele) {
          // direct mapping for selected allele
          tmp.set(pep, v);
        } else {
          // no allele selected: take min across alleles
          const prev = tmp.get(pep);
          tmp.set(pep, prev == null ? v : Math.min(prev, v));
        }
      }
      pctMap = tmp;
    }
  } catch {}

  const el = peptideChartScan({
    data: rows,
    posExtent,
    rowHeight: 18,
    sizeFactor: 1.1,
    selectedAllele: selAllele,
    percentileByPeptide: pctMap,
    onReady: (xBase) => {
      // no-op
    },
    onZoom: (zx, t) => {
      __zoomSync.transform = t;
      const hm = __zoomSync.heatmapEl;
      const a  = __zoomSync.pepAllele;
      if (hm && typeof hm.__setZoom === "function") hm.__setZoom(t);
      if (a && typeof a.__setZoom === "function") a.__setZoom(t);
    }
  });
  peptideSlot.appendChild(el);
  __zoomSync.peptideEl = el;
  if (__zoomSync.transform && typeof el.__setZoom === "function") {
    el.__setZoom(__zoomSync.transform);
  }
  try { updateChartDlButtons(); } catch {}
}

/* CSV download */
let pepCsvUrl = null;
function buildPeptideCSV(rows) {
  if (!rows || !rows.length) return "";
  const cols = ["sequence_index","sequence_id","peptide","start","length"];
  const esc = v => {
    const s = v == null ? "" : String(v);
    return /[",\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s;
  };
  return [cols.join(","), ...rows.map(r => cols.map(c => esc(r[c])).join(","))].join("\n");
}
function updatePeptideDownloadForSeq(seqIdx) {
  if (pepCsvUrl) { try { URL.revokeObjectURL(pepCsvUrl); } catch {} pepCsvUrl = null; }
  const rows = alignedForSeq(seqIdx);
  if (!rows.length) { dlPepsBtn.disabled = true; return; }
  const csv = buildPeptideCSV(rows);
  pepCsvUrl = URL.createObjectURL(new Blob([csv], { type:"text/csv" }));
  dlPepsBtn.disabled = false;
}
dlPepsBtn.onclick = () => {
  if (!pepCsvUrl) { alert("No aligned peptides to download."); return; }
  const a = document.createElement("a");
  a.href = pepCsvUrl;
  a.download = "aligned_peptides.csv";
  a.click();
};
invalidation.then(() => { if (pepCsvUrl) URL.revokeObjectURL(pepCsvUrl); });

```

