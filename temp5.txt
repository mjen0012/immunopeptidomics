let fastaDebounceTimer = null;

async function parseAndApplyFASTA(rawText) {
  const { seqs, fastaText, issues } = parseFastaForIEDB(rawText, { wrap: false });

  // Update app state (textarea shows RAW; we store SANITIZED fastaText)
  setMut(seqListMut, seqs);
  setMut(chosenSeqIdMut, seqs[0]?.id ?? null);
  setMut(fastaTextMut, fastaText);

  // Refill + enable the Sequence dropdown (fires its onChange handler)
  refreshSeqOptions(seqSelectCtrl);
  {
    const aligned = alignAllPeptides(seqListMut.value || [], peptideListMut.value || []);
    alignedPepsMut.value = aligned;
    latestAlignedPepsMut.value = aligned;
   {
     const seqNow = selectedSeqIndex();
     const lenNow = Number(heatLenCtrl?.value);
     const selAllele = (selectedAlleleMut && "value" in selectedAlleleMut) ? selectedAlleleMut.value : null;
     renderPeptideTrack(seqNow, lenNow, selAllele);
   }
    updatePeptideDownloadForSeq(selectedSeqIndex());
  }
}

const onFastaInput = () => {
  if (fastaBox.__isProg()) return; // ignore programmatic changes
  clearTimeout(fastaDebounceTimer);
  fastaDebounceTimer = setTimeout(() => {
    parseAndApplyFASTA(fastaBox.value);
  }, DEBOUNCE_MS);
};
fastaBox.textarea.addEventListener("input", onFastaInput);
invalidation.then(() => fastaBox.textarea.removeEventListener("input", onFastaInput));


```

```js
// Robust upload wiring (wrapper 'input' + file 'change' + restore)
{
  const isFileLike = (f) => f && typeof f.text === "function";

  const processFile = async (file) => {
    if (!isFileLike(file)) {
      // Clear state
      fastaBox.setText("");
      setMut(seqListMut, []);
      setMut(chosenSeqIdMut, null);
      setMut(fastaTextMut, "");
      // Disable/clear sequence selector
      if (seqSelectCtrl?.setOptions) seqSelectCtrl.setOptions([], { prefer: 1 });
      return;
    }

    let txt = "";
    try { txt = await file.text(); } catch {}
    // 1) show RAW in the textarea (no event)
    fastaBox.setText(txt);
    // 2) parse and apply once (donâ€™t wait for debounce)
    await parseAndApplyFASTA(txt);
  };

  // 1) Wrapper root emits 'input' (uploadButton.js does this)
  const onRootInput = async () => {
    const v = uploadSeqBtn?.value;
    const file = Array.isArray(v) ? v[0] : v;
    await processFile(file ?? null);
  };
  uploadSeqBtn.addEventListener("input", onRootInput);
