  if (m) parts.push(m);
  return parts.join("_") + ".svg";
}

dlPeptideSvgBtn.addEventListener("click", () => downloadSvgFromSlot(peptideSlot, makeChartFilename("peptide")));
dlHeatmapSvgBtn.addEventListener("click", () => downloadSvgFromSlot(heatmapSlot, makeChartFilename("heatmap")));
dlAlleleSvgBtn.addEventListener("click", () => downloadSvgFromSlot(peptideScanSlot, makeChartFilename("allele")));


function updateChartDlButtons() {
  try { dlPeptideSvgBtn.disabled = !peptideSlot?.querySelector?.("svg"); } catch { dlPeptideSvgBtn.disabled = true; }
  try { dlHeatmapSvgBtn.disabled = !heatmapSlot?.querySelector?.("svg"); } catch { dlHeatmapSvgBtn.disabled = true; }
  try { dlAlleleSvgBtn.disabled  = !peptideScanSlot?.querySelector?.("svg"); } catch { dlAlleleSvgBtn.disabled = true; }
}

// Observe the chart slots so this cell is only downstream of them
let __dlObs;
function attachDlObservers() {
  try { __dlObs?.disconnect?.(); } catch {}
  __dlObs = new MutationObserver(() => updateChartDlButtons());
  [peptideSlot, heatmapSlot, peptideScanSlot].forEach(el => {
    try { __dlObs.observe(el, { childList: true, subtree: true }); } catch {}
  });
  // set initial state
  updateChartDlButtons();
}
attachDlObservers();
invalidation.then(() => { try { __dlObs?.disconnect?.(); } catch {} });
```

```js
// Color key legend (matches heatmap colors): 0–2 blue→white, 2–50 white→red, 50–100 red
import * as d3 from "npm:d3@7";

const colorKeySlot = html`<div></div>`;

function renderColorKey() {
  const BLUE_MAX = 2, RED_MIN = 50;

  const root = document.createElement("div");
  root.style.fontFamily = "'Roboto', sans-serif";

  const label = document.createElement("label");
  label.textContent = "Key";
  label.style.cssText = "display:block;margin:0 0 8px 0;font:500 13px/1.3 'Roboto',sans-serif;color:#111;";

  // Colors matching charts
  const blue0 = d3.interpolateBlues(1); // deep
  const blueW = d3.interpolateBlues(0); // white
  const redW  = d3.interpolateReds(0);  // white
  const red1  = d3.interpolateReds(1);  // deep red

  // Wrapper with room for tick labels
  const wrap = document.createElement("div");
  wrap.style.position = "relative";
  wrap.style.paddingBottom = "24px"; // room for ticks + labels

  // Box sized like other controls (selects) for a unified row look
  const box = document.createElement("div");
  box.style.cssText = `
    height:36px; width:100%; box-sizing:border-box;
    border:1px solid #bbb; border-radius:6px; background:#fff; overflow:hidden;
    display:grid; grid-template-columns:1fr 1fr 1fr; position:relative;
  `;
  wrap.appendChild(box);

  // Three equal segments with a visual break between them
  const s1 = document.createElement("div");
  s1.style.cssText = `background: linear-gradient(to right, ${blue0}, ${blueW});`;
  const s2 = document.createElement("div");
  s2.style.cssText = `background: linear-gradient(to right, ${redW}, ${red1});`;
  const s3 = document.createElement("div");
  s3.style.cssText = `background: ${red1};`;
  box.append(s1, s2, s3);

  // No end lines at 0 or 100 per design

  // Prominent double-line breaks at 2 and 50 (segment boundaries)
  const breaks = [33.3333, 66.6667];
  for (const p of breaks) {
    // double crisp lines with a thin white gap; do not intrude into value labels
    const gap = document.createElement("div");
    gap.style.cssText = `
      position:absolute; top:-2px; bottom:18px; width:2px; left:${p}%;
      background:#fff; transform:translateX(-1px); pointer-events:none;
    `;
    const leftL = document.createElement("div");
    leftL.style.cssText = `
      position:absolute; top:-3px; bottom:18px; width:1px; left:calc(${p}% - 2px);
      background:#94a3b8; transform:translateX(-0.5px); pointer-events:none;
    `;
    const rightL = document.createElement("div");
    rightL.style.cssText = `
      position:absolute; top:-3px; bottom:18px; width:1px; left:calc(${p}% + 2px);
      background:#94a3b8; transform:translateX(-0.5px); pointer-events:none;
    `;
    wrap.append(gap, leftL, rightL);
  }

  // Compose tick positions array for ticks + labels
  const tickPerc = [0, 33.3333, 66.6667, 100];
  // Tick marks (matching slider style)
  for (const p of tickPerc) {
    const tick = document.createElement("div");
    tick.style.cssText = `
      position:absolute; left:${p}%; bottom:14px; width:1px; height:8px;
      background:#bdbdbd; transform:translateX(-0.5px); pointer-events:none;
    `;
    wrap.appendChild(tick);
  }

  // Tick labels aligned to the same positions: 0, 2, 50, 100
  const labels = [0, BLUE_MAX, RED_MIN, 100];
  labels.forEach((val, i) => {
    const t = document.createElement("span");
    const p = tickPerc[i];
    t.textContent = String(val);
    t.style.cssText = `
      position:absolute; left:${p}%; bottom:0; transform:translateX(-50%);
      font:12px/1 'Roboto', sans-serif; color:#424242; user-select:none;
    `;
    wrap.appendChild(t);
  });
