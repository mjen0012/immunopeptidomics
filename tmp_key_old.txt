const peptideKeyEl = (() => {
  // reactive deps
  colourAttr; percMode; proteinCommitted;

  // SIMPLE RULE: if the radio is NOT attribute_1/2/3 â‡’ allele mode
  const inAlleleMode = !/^attribute_[123]$/i.test(String(colourAttr));

  if (inAlleleMode) {
    return peptideColourKey({
      label        : "Peptide colour key",
      isAllele     : true,
      mode         : percMode,   // EL/BA
      includeNoData: true,       // always show â€œNo dataâ€ (per your #2)
      missingColor : "#f0f0f0"
    });
  }

  // Attribute mode (unchanged)
  const pepRows = peptidesAligned.filter(d => d.protein === proteinCommitted);
  const { cats, hasMissing } = attrCats(pepRows, colourAttr);
  const scale = makePeptideScale(cats.length ? cats : ["dummy"]);

  return peptideColourKey({
    label        : "Peptide colour key",
    isAllele     : false,
    categories   : cats,
    colourScale  : scale,
    includeNoData: hasMissing,
    missingColor : "#f0f0f0"
  });
})();

```

```js
// Keep proteins temp table/view in sync with the committed protein selection, with debounce
{
  const pid = committedProteinId ?? DEFAULT_PROTEIN; // reactive dep
  const state = (globalThis.__proteinViewState ??= { last: null });
  if (state.last === pid) {
    try { console.info('[IAV2] proteins table reuse', { protein: pid }); } catch {}
  } else {
    const url = `https://gbxc45oychilox63.public.blob.vercel-storage.com/${encodeURIComponent(pid)}.parquet`;
    await db.sql`CREATE OR REPLACE TABLE proteins_cache AS
      SELECT * FROM read_parquet('${url}')`;
    await db.sql`CREATE OR REPLACE VIEW proteins AS SELECT * FROM proteins_cache`;
    state.last = pid;
    try { console.info('[IAV2] proteins table materialised', { protein: pid }); } catch {}
  }
}
```

```js
/* Sequence set */
const seqSetInput = radioButtons(
  ["All sequences", "Unique sequences"],
  { label: "Sequence set:", value: "All sequences" }
);
const seqSet = Generators.input(seqSetInput);

/* Cell colouring */
const colourModeInput = radioButtons(
  ["Mismatches", "Properties"],
  { label: "Cell colouring:", value: "Mismatches" }
);
const colourMode = Generators.input(colourModeInput);

const aaKeyEl = aaColourKey({
  label: "Amino-acid colour key",   // or "" to hide the heading
  square: 22,
  gap: 6,
  showGroupLabels: true
});
```

<!-- Data Source Switcher -->
```js
/* Any Filters Present */
function noExtraFilters() {
  return (
    !genotypesCommitted.length          &&
    !hostsCommitted.length              &&
    !hostCategoryCommitted.length       &&
    !countriesCommitted.length          &&
    !(collectionDatesCommitted.from || collectionDatesCommitted.to) &&
    !(releaseDatesCommitted.from   || releaseDatesCommitted.to)
  );
}
```

```js
/* Calculate Position Data */
const positionStats = (
  noExtraFilters()
    ? db.sql`                       -- fast path (unchanged)
        SELECT position, aminoacid,
               frequency_all, total_all, value,
               frequency_unique, total_unique, value_unique
        FROM sequencecalc
        WHERE protein = ${proteinCommitted}`
    : db.sql`                       -- live path (narrow projection)
        WITH
        filtered AS (
          /* Only the columns used in WHERE + the one we actually need: sequence */
          SELECT sequence
          FROM   proteins
          WHERE  protein = ${ proteinCommitted }

          AND ${ genotypesCommitted.length
                  ? sql`genotype IN (${ genotypesCommitted })`
                  : sql`TRUE` }

          AND ${ hostsCommitted.length
                  ? sql`host IN (${ hostsCommitted })`
                  : sql`TRUE` }

          AND ${
                hostCategoryCommitted.includes('Human') &&
                !hostCategoryCommitted.includes('Non-human')
                  ? sql`host = 'Homo sapiens'`
                  : (!hostCategoryCommitted.includes('Human') &&
                     hostCategoryCommitted.includes('Non-human'))
                      ? sql`host <> 'Homo sapiens'`
                      : sql`TRUE`
              }

          AND ${ countriesCommitted.length
                  ? sql`country IN (${ countriesCommitted })`
                  : sql`TRUE` }

          AND ${
            collectionDatesCommitted.from || collectionDatesCommitted.to
              ? sql`
                  TRY_CAST(
                    CASE
                      WHEN collection_date IS NULL OR collection_date = '' THEN NULL
                      WHEN LENGTH(collection_date)=4  THEN collection_date || '-01-01'
                      WHEN LENGTH(collection_date)=7  THEN collection_date || '-01'
                      ELSE collection_date
                    END AS DATE
                  )
                  ${
                    collectionDatesCommitted.from && collectionDatesCommitted.to
                      ? sql`BETWEEN CAST(${ collectionDatesCommitted.from } AS DATE)
                               AND   CAST(${ collectionDatesCommitted.to   } AS DATE)`
                      : collectionDatesCommitted.from
                          ? sql`>= CAST(${ collectionDatesCommitted.from } AS DATE)`
                          : sql`<= CAST(${ collectionDatesCommitted.to   } AS DATE)`
                  }
                `
              : sql`TRUE`
          }

          AND ${
            releaseDatesCommitted.from || releaseDatesCommitted.to
              ? sql`
                  TRY_CAST(
                    CASE
                      WHEN release_date IS NULL OR release_date = '' THEN NULL
                      WHEN LENGTH(release_date)=4 THEN release_date || '-01-01'
                      WHEN LENGTH(release_date)=7 THEN release_date || '-01'
                      ELSE release_date
                    END AS DATE
                  )
                  ${
                    releaseDatesCommitted.from && releaseDatesCommitted.to
                      ? sql`BETWEEN CAST(${ releaseDatesCommitted.from } AS DATE)
                               AND   CAST(${ releaseDatesCommitted.to   } AS DATE)`
                      : releaseDatesCommitted.from
                          ? sql`>= CAST(${ releaseDatesCommitted.from } AS DATE)`
                          : sql`<= CAST(${ releaseDatesCommitted.to   } AS DATE)`
                  }
                `
              : sql`TRUE`
          }
        ),

        /* downstream identicalâ€¦ */
        parsed AS ( SELECT sequence, LENGTH(sequence) AS len FROM filtered ),
        pos    AS ( SELECT p.sequence, gs.position
                    FROM parsed p CROSS JOIN generate_series(1, p.len) AS gs(position) ),
        chars  AS ( SELECT position, SUBSTRING(sequence, position, 1) AS aminoacid FROM pos ),
        counts AS ( SELECT position, aminoacid, COUNT(*) AS cnt FROM chars GROUP BY position, aminoacid ),
        totals AS ( SELECT position, SUM(cnt) AS total   FROM counts GROUP BY position ),

        filtered_u AS ( SELECT DISTINCT sequence FROM filtered ),
        parsed_u   AS ( SELECT sequence, LENGTH(sequence) AS len FROM filtered_u ),
        pos_u      AS ( SELECT p.sequence, gs.position
                        FROM parsed_u p CROSS JOIN generate_series(1, p.len) AS gs(position) ),
        chars_u    AS ( SELECT position, SUBSTRING(sequence, position, 1) AS aminoacid FROM pos_u ),
        counts_u   AS ( SELECT position, aminoacid, COUNT(*) AS cnt FROM chars_u GROUP BY position, aminoacid ),
        totals_u   AS ( SELECT position, SUM(cnt) AS total   FROM counts_u GROUP BY position )

        SELECT
          c.position, c.aminoacid,
          CAST(c.cnt AS INT)    AS frequency_all,
          CAST(t.total AS INT)  AS total_all,
          (c.cnt::DOUBLE) / t.total AS value,
          CAST(cu.cnt AS INT)   AS frequency_unique,
          CAST(tu.total AS INT) AS total_unique,
          (cu.cnt::DOUBLE) / tu.total AS value_unique
        FROM   counts c
        JOIN   totals t USING (position)
        LEFT   JOIN counts_u cu ON cu.position = c.position AND cu.aminoacid = c.aminoacid
        LEFT   JOIN totals_u tu USING (position)
        ORDER  BY c.position, c.aminoacid
    `
);

```

```js
/* JS Array for Plotting */
const aaFrequencies = (
  await (globalThis.__perfUtils?.perfAsync?.('sql: positionStats -> aaFrequencies', async () => await positionStats.toArray()))
).map(r => {
  const all  = Number(r.value       );
  const uniq = Number(r.value_unique);
  return {
    position        : Number(r.position),
    aminoacid       : r.aminoacid,
    value_selected  : (seqSet === "Unique sequences" ? uniq : all)
  };
});

/* Stacked Bar Chart Data */
const stackedBars = (() => {
  const rows = [];
  for (const [pos, arows] of d3.group(aaFrequencies, d=>d.position)) {
    const maxVal = d3.max(arows, d=>d.value_selected);
    arows
      .filter(d => d.value_selected !== maxVal)
      .sort((a,b)=>d3.descending(a.value_selected,b.value_selected))
      .reduce((y0,d)=>{
        rows.push({
          position : +pos,
          aminoacid: d.aminoacid,
          y0,
          y1      : y0 += d.value_selected
        });
        return y0;
      },0);
  }
  return rows;
})();

/* Area Chart Data */
const areaData = Array.from(
  d3.group(aaFrequencies, d => d.position),
  ([position, rows]) => {
    const top = rows.reduce((a, b) =>
      b.value_selected > a.value_selected ? b : a
    );
    return {
      position : +position,
      value    : top.value_selected,
      aminoacid: top.aminoacid
    };
  }
).sort((a, b) => d3.ascending(a.position, b.position));

/* â”€â”€â”€ reference (aligned) sequence rows â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const refAligned = fastaAligned.find(d => d.protein === proteinCommitted )
                     ?.aligned_sequence ?? "";               // empty string if none
const refRows = refAligned.split("")
  .map((aa,i)=>({ position:i+1, aminoacid:aa }));

/* â”€â”€â”€ consensus rows (respecting the All / Unique toggle) â”€â”€â”€ */
const consensusRows = Array.from(
  d3.rollups(
    aaFrequencies,
    v => v.reduce((m,r)=> r.value_selected>m.value_selected? r : m),
    d => d.position
  ),
  ([pos, r]) => ({ position:+pos, aminoacid:r.aminoacid })
).sort((a,b)=>d3.ascending(a.position,b.position));

/* facetArea :  Map<facetKey â†’ [{position,value,aminoacid}]> */
const facetArea = new Map();


if (positionFacetStats !== null) {
  const rows = await (globalThis.__perfUtils?.perfAsync?.('sql: positionFacetStats', async () => await positionFacetStats.toArray()));

  /* choose the right value column once */
  const valueField = (seqSet === "Unique sequences" ? "value_unique" : "value");

  for (const [facetKey, groupRows] of d3.group(rows, d => d.facet)) {
    const areaRows = Array.from(
      d3.group(groupRows, d => d.position),
      ([position, posRows]) => {
        const top = posRows.reduce(
          (m, x) => (x[valueField] > m[valueField] ? x : m)
        );
        return {
          position : +position,
          value    : Number(top[valueField]),
          aminoacid: top.aminoacid
        };
      }
    ).sort((a,b)=>d3.ascending(a.position,b.position));

    facetArea.set(facetKey ?? "Unknown", areaRows);   // null â†’ "Unknown"
  }
}

```

```js
/* Mutable Peptide Selected */
const selectedPeptide = Mutable(null);
const setSelectedPeptide = x => selectedPeptide.value = x;

const selectedStart = Mutable(null);
const setSelectedStart = x => selectedStart.value = x;

const selectedLength = Mutable(null);
const setSelectedLength = x => selectedLength.value = x;
```

```js
/* Peptide JS Array */
const rowsRaw = await (globalThis.__perfUtils?.perfAsync?.('sql: peptideProps', async () => await peptideProps.toArray()));

/* Peptide Unique vs All Switcher */
const useUnique = seqSet === "Unique sequences";

const propCol = useUnique ? "proportion_unique" : "proportion_all";
const freqCol = useUnique ? "frequency_unique"  : "frequency_all";
const totCol  = useUnique ? "total_unique"      : "total_all";

/* Map Peptide Plot Data */
const heatmapData = rowsRaw.map(r => ({
  peptide   : r.peptide,
  proportion: Number(r[propCol]),
  frequency : Number(r[freqCol]),
  total     : Number(r[totCol])
}));

/* Create Peptide Plot */
const heatmapSVG = peptideHeatmap({
  data        : heatmapData,                        // peptides (ungapped)
  selected    : selectedPeptide,                    // may include '-'
  colourMode  : colourMode,
  // â”€â”€ NEW overlay props:
  alleleData  : chartRowsI,                         // cache + API (snake_case)
  alleles     : Array.from(selectedI || []),
  mode        : percMode,                           // "EL" | "BA"
  showAlleles : true,
  baseCell    : 28,
  height0     : 280,
  margin      : { top:20, right:150, bottom:20, left:4 }
});

```

```js
// Perf: size of aaFrequencies for plotting
globalThis.__perfUtils?.logArray?.('aaFrequencies', aaFrequencies);
```

```js
/* Reset Peptide Plot when Protein Changes */
{
  const _ = proteinCommitted;
  setSelectedPeptide(null);
  setSelectedStart(null);
  setSelectedLength(null);
}

```


```js
/* -------- facetChoices  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Re-evaluates automatically whenever any committed filter changes.
   A facet option appears only when the user has at least ONE value
   selected for that attribute.                                        */
const facetChoices = (() => {
  const list = ["None"];                 // always available

  if (genotypesCommitted.length) list.push("Genotype");
  if (hostsCommitted.length)     list.push("Host");
  if (countriesCommitted.length) list.push("Country");

  return list;
})();
```
```js

/* -------- radio input  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Re-created every time `facetChoices` changes, so the UI never
   shows options that would facet the *entire* data set.                */
const facetSelectInput = Inputs.radio(
  facetChoices,
  {
    label : "Facet by:",
    value : facetChoices[0]              // whichever is first (â€œNoneâ€)
  }
);
const facetSelect = Generators.input(facetSelectInput);


```

```js
// how many facet levels to render at once (tune as needed)
const MAX_FACETS = 6;

// Unique vs All toggle (you already have this elsewhere; mirroring here)
const useUnique = (seqSet === "Unique sequences");

/* Replaces your entire positionFacetStats cell */
const positionFacetStats =
  (facetSelect === "None" || noExtraFilters())
    ? null
    : db.sql`
WITH base AS (
  SELECT
    ${
      facetSelect === "Genotype"
        ? sql`genotype`
        : facetSelect === "Host"
          ? sql`host`
          : sql`country`
    } AS facet,
    sequence
  FROM proteins
  /* ðŸ”´ push ALL filters here so we only touch the committed proteinâ€™s rows */
  WHERE protein = ${proteinCommitted}

    AND ${ genotypesCommitted.length
            ? sql`genotype IN (${ genotypesCommitted })` : sql`TRUE` }

    AND ${ hostsCommitted.length
            ? sql`host IN (${ hostsCommitted })` : sql`TRUE` }

    AND ${
          hostCategoryCommitted.includes('Human') &&
          !hostCategoryCommitted.includes('Non-human')
            ? sql`host = 'Homo sapiens'`
            : (!hostCategoryCommitted.includes('Human') &&
               hostCategoryCommitted.includes('Non-human'))
                ? sql`host <> 'Homo sapiens'`
                : sql`TRUE`
        }

    AND ${ countriesCommitted.length
            ? sql`country IN (${ countriesCommitted })` : sql`TRUE` }

    AND ${
      collectionDatesCommitted.from || collectionDatesCommitted.to
        ? sql`
            TRY_CAST(
              CASE
                WHEN collection_date IS NULL OR collection_date = '' THEN NULL
                WHEN LENGTH(collection_date)=4  THEN collection_date || '-01-01'
                WHEN LENGTH(collection_date)=7  THEN collection_date || '-01'
                ELSE collection_date
              END AS DATE
            )
            ${
              collectionDatesCommitted.from && collectionDatesCommitted.to
                ? sql`BETWEEN CAST(${collectionDatesCommitted.from} AS DATE)
                         AND   CAST(${collectionDatesCommitted.to  } AS DATE)`
                : collectionDatesCommitted.from
                    ? sql`>= CAST(${collectionDatesCommitted.from} AS DATE)`
                    : sql`<= CAST(${collectionDatesCommitted.to   } AS DATE)`
            }
          ` : sql`TRUE`
    }

    AND ${
      releaseDatesCommitted.from || releaseDatesCommitted.to
        ? sql`
            TRY_CAST(
              CASE
                WHEN release_date IS NULL OR release_date = '' THEN NULL
                WHEN LENGTH(release_date)=4 THEN release_date || '-01-01'
                WHEN LENGTH(release_date)=7 THEN release_date || '-01'
                ELSE release_date
              END AS DATE
            )
            ${
              releaseDatesCommitted.from && releaseDatesCommitted.to
                ? sql`BETWEEN CAST(${releaseDatesCommitted.from} AS DATE)
                         AND   CAST(${releaseDatesCommitted.to  } AS DATE)`
                : releaseDatesCommitted.from
                    ? sql`>= CAST(${releaseDatesCommitted.from} AS DATE)`
                    : sql`<= CAST(${releaseDatesCommitted.to   } AS DATE)`
            }
          ` : sql`TRUE`
    }
),

/* for the â€œUniqueâ€ path, dedupe sequences now to avoid doubling later */
b AS (
  ${ useUnique
      ? sql`SELECT DISTINCT facet, sequence FROM base`
      : sql`SELECT facet, sequence FROM base` }
),

/* keep only the busiest facet levels to cap worst-case memory */
top_facets AS (
  SELECT facet
  FROM b
  GROUP BY facet
  ORDER BY COUNT(*) DESC NULLS LAST
  LIMIT ${MAX_FACETS}
),

b2 AS (
  SELECT b.facet, b.sequence
  FROM b
  JOIN top_facets t USING (facet)
),

/* explode *only* the already-filtered, capped set */
parsed AS ( SELECT facet, sequence, LENGTH(sequence) AS len FROM b2 ),
pos    AS ( SELECT facet, sequence, gs.position
           FROM parsed p, generate_series(1, p.len) AS gs(position) ),
chars  AS ( SELECT facet, position,
                   SUBSTRING(sequence, position, 1) AS aminoacid
            FROM pos ),

/* counts + totals */
counts AS ( SELECT facet, position, aminoacid, COUNT(*) AS cnt
            FROM chars
            GROUP BY facet, position, aminoacid ),
totals AS ( SELECT facet, position, SUM(cnt) AS total
            FROM counts
            GROUP BY facet, position ),

/* rank in SQL so we only return the single top-AA per position */
ranked AS (
  SELECT
    facet, position, aminoacid,
    CAST(cnt   AS INT)   AS frequency,
    CAST(total AS INT)   AS total,
    (cnt::DOUBLE)/total  AS value_current,  -- the only metric we need
    ROW_NUMBER() OVER (
      PARTITION BY facet, position
      ORDER BY (cnt::DOUBLE)/total DESC, aminoacid
    ) AS r
  FROM counts JOIN totals USING (facet, position)
)

/* name the column to match your JS switch: value or value_unique */
SELECT
  facet, position, aminoacid, frequency, total,
  ${ useUnique
      ? sql`value_current AS value_unique, NULL::DOUBLE AS value`
      : sql`value_current AS value,        NULL::DOUBLE AS value_unique` }
FROM ranked
WHERE r = 1
ORDER BY facet, position, aminoacid
`;

```

```js
/*****************************************************************
 * 1.  Prepare an in-memory table of all aligned peptides
 *****************************************************************/
const peptideParams = peptidesAligned
  .filter(d => d.peptide_aligned && d.start && String(d.protein || '').toUpperCase() === committedProteinId)   // only usable rows (committed protein only)
  .map(d => ({
    protein : d.protein,
    peptide : d.peptide_aligned,
    start   : d.start,           // 1-based aligned start
    len     : d.aligned_length
  }));  
```

```js
const joinSql = (arr, sep = sql`, `) =>
  arr.reduce((acc, cur, i) => (i === 0 ? cur : sql`${acc}${sep}${cur}`), sql``);

/*****************************************************************
 * 2 Â· build VALUES rows for every uploaded peptide
 *****************************************************************/
const peptideValues = peptidesAligned
  .filter(d => d.peptide_aligned && d.start && String(d.protein || '').toUpperCase() === committedProteinId)          // skip unusable rows (committed protein only)
  .map(r =>
    sql`(${r.protein}, ${r.peptide_aligned},
         ${r.start}, ${r.aligned_length})`
  );
```

```js
/* ------------------------------------------------------------------
   Create a SINGLE memoâ€‘cache on the global object (survives reloads)
   ------------------------------------------------------------------*/
if (!globalThis.__peptideCache) {
  globalThis.__peptideCache = { key: null, table: null };
}

```



```js
/********************************************************************
 * getPeptidePropsAll()    Â·Â v2                                      *
 * â€‘ reâ€‘runs only when:                                              *
 *     â€¢ any nonâ€‘protein filter changes, OR                          *
 *     â€¢ the uploaded peptide set changes (length)                   *
 ********************************************************************/
function getPeptidePropsAll_old() {

  /* 1. build a key that now ALSO tracks the peptide list size */
  const filterKey = JSON.stringify({
    genotypes       : [...genotypesCommitted].sort(),
    hosts           : [...hostsCommitted].sort(),
    hostCategory    : [...hostCategoryCommitted].sort(),
    countries       : [...countriesCommitted].sort(),
    collectionDates : collectionDatesCommitted,
    releaseDates    : releaseDatesCommitted,
    nPeptides       : peptideValues.length            // â† NEW
  });

  /* 2. return cached table when key matches ----------------------- */
  if (globalThis.__peptideCache?.key === filterKey &&
      globalThis.__peptideCache.table) {
    return globalThis.__peptideCache.table;              // âš¡ hit
  }

  /* 3. if still no peptides, return an empty table ---------------- */
  if (peptideValues.length === 0) {
    const empty = db.sql`SELECT NULL::VARCHAR AS protein LIMIT 0`;
    globalThis.__peptideCache = { key: filterKey, table: empty };
    return empty;
  }

  /* 4. heavy query (exact body unchanged) ------------------------ */
  const table = db.sql`
    WITH
      params(protein, peptide, start, len) AS (
        VALUES ${joinSql(peptideValues)}
      ),

    /* 2. filtered proteins (all active filters EXCEPT protein) ---- */
    /* In getPeptidePropsAll(): replace the filtered CTE */
    filtered AS (
      SELECT protein, sequence
      FROM   proteins
      WHERE  1 = 1
        AND (${genotypesCommitted.length
                ? sql`genotype IN (${genotypesCommitted})` : sql`TRUE`})
        AND (${hostsCommitted.length
                ? sql`host IN (${hostsCommitted})` : sql`TRUE`})
        AND (${hostCategoryCommitted.includes('Human') &&
              !hostCategoryCommitted.includes('Non-human')
                ? sql`host = 'Homo sapiens'`
                : (!hostCategoryCommitted.includes('Human') &&
                  hostCategoryCommitted.includes('Non-human'))
                    ? sql`host <> 'Homo sapiens'` : sql`TRUE`})
        AND (${countriesCommitted.length
                ? sql`country IN (${countriesCommitted})` : sql`TRUE`})

        AND ${
          collectionDatesCommitted.from || collectionDatesCommitted.to
            ? sql`TRY_CAST(
                    CASE
                      WHEN collection_date IS NULL OR collection_date = '' THEN NULL
                      WHEN LENGTH(collection_date)=4  THEN collection_date || '-01-01'
                      WHEN LENGTH(collection_date)=7  THEN collection_date || '-01'
                      ELSE collection_date
                    END AS DATE
                  )
                  ${
                    collectionDatesCommitted.from && collectionDatesCommitted.to
                      ? sql`BETWEEN CAST(${collectionDatesCommitted.from} AS DATE)
                              AND   CAST(${collectionDatesCommitted.to  } AS DATE)`
                      : collectionDatesCommitted.from
                          ? sql`>= CAST(${collectionDatesCommitted.from} AS DATE)`
                          : sql`<= CAST(${collectionDatesCommitted.to   } AS DATE)`
                  }`
            : sql`TRUE`
        }

        AND ${
          releaseDatesCommitted.from || releaseDatesCommitted.to
            ? sql`TRY_CAST(
                    CASE
                      WHEN release_date IS NULL OR release_date = '' THEN NULL
                      WHEN LENGTH(release_date)=4 THEN release_date || '-01-01'
                      WHEN LENGTH(release_date)=7 THEN release_date || '-01'
                      ELSE release_date
                    END AS DATE
                  )
                  ${
                    releaseDatesCommitted.from && releaseDatesCommitted.to
                      ? sql`BETWEEN CAST(${releaseDatesCommitted.from} AS DATE)
                              AND   CAST(${releaseDatesCommitted.to  } AS DATE)`
                      : releaseDatesCommitted.from
                          ? sql`>= CAST(${releaseDatesCommitted.from} AS DATE)`
                          : sql`<= CAST(${releaseDatesCommitted.to   } AS DATE)`
                  }`
            : sql`TRUE`
        }
    ),

    /* 3. allâ€‘sequence tallies ------------------------------------ */
    ex_all AS (
      SELECT p.protein, p.peptide, COUNT(*) AS cnt_all
      FROM   filtered f
      JOIN   params   p
        ON   f.protein = p.protein
       AND   SUBSTR(f.sequence,
                    CAST(p.start AS BIGINT),
                    CAST(p.len   AS BIGINT)) = p.peptide
      GROUP BY p.protein, p.peptide
    ),
    tot_all AS (
      SELECT protein, COUNT(*) AS total_all
      FROM   filtered
      GROUP  BY protein
    ),

    /* 4. uniqueâ€‘sequence tallies --------------------------------- */
    filtered_u AS ( SELECT DISTINCT protein, sequence FROM filtered ),
    ex_u AS (
      SELECT p.protein, p.peptide, COUNT(*) AS cnt_unique
      FROM   filtered_u fu
      JOIN   params     p
        ON   fu.protein = p.protein
       AND   SUBSTR(fu.sequence,
                    CAST(p.start AS BIGINT),
                    CAST(p.len   AS BIGINT)) = p.peptide
      GROUP BY p.protein, p.peptide
    ),
    tot_u AS (
      SELECT protein, COUNT(*) AS total_unique
      FROM   filtered_u
      GROUP  BY protein
    ),

    /* 5. merge ---------------------------------------------------- */
    combined AS (
      SELECT
        p.protein,
        p.peptide,

        /* all sequences */
        CAST(COALESCE(a.cnt_all,0)  AS INT) AS frequency_all,
        CAST(ta.total_all           AS INT) AS total_all,
        CASE WHEN ta.total_all = 0
             THEN 0.0
             ELSE COALESCE(a.cnt_all,0)*1.0/ta.total_all
        END                                 AS proportion_all,

        /* unique sequences */
        CAST(COALESCE(u.cnt_unique,0) AS INT) AS frequency_unique,
        CAST(tu.total_unique          AS INT) AS total_unique,
        CASE WHEN tu.total_unique = 0
             THEN 0.0
             ELSE COALESCE(u.cnt_unique,0)*1.0/tu.total_unique
        END                                 AS proportion_unique
      FROM   params        p
      LEFT   JOIN ex_all   a  USING (protein, peptide)
      LEFT   JOIN tot_all  ta USING (protein)
      LEFT   JOIN ex_u     u  USING (protein, peptide)
      LEFT   JOIN tot_u    tu USING (protein)
    )

    SELECT *
    FROM   combined
    ORDER  BY protein, proportion_all DESC;
  `;

  /* ----- update cache & return ----------------------------------- */
  globalThis.__peptideCache = { key: filterKey, table };
  return table;
}

``` 

```js
/* New: getPeptidePropsAll using unified tallies (single protein) */
function getPeptidePropsAll() {
  const pid = committedProteinId; // reactive

  // uploaded peptides for committed protein only
  const uploaded = peptidesAligned
    .filter(d => d.peptide_aligned && d.start && String(d.protein || '').toUpperCase() === pid);
  const uploadedSet = new Set(uploaded.map(d => String(d.peptide_aligned).toUpperCase()));

  // windows set from uploaded peptides
  const windows = [...new Map(
    uploaded.map(r => [`${r.start}|${r.aligned_length}`, { start: +r.start, len: +r.aligned_length }])
  ).values()];

  const filterKey = JSON.stringify({
    protein         : pid,
    genotypes       : [...genotypesCommitted].sort(),
    hosts           : [...hostsCommitted].sort(),
    hostCategory    : [...hostCategoryCommitted].sort(),
    countries       : [...countriesCommitted].sort(),
    collectionDates : collectionDatesCommitted,
    releaseDates    : releaseDatesCommitted,
    nPeptides       : uploadedSet.size,
    windowsKey      : windows.map(w => `${w.start}|${w.len}`).sort().join(',')
  });

  if (globalThis.__peptideCache?.key === filterKey && globalThis.__peptideCache.table) {
    return globalThis.__peptideCache.table;
  }

  if (!uploadedSet.size || !windows.length) {
    const empty = { toArray: async () => [] };
    globalThis.__peptideCache = { key: filterKey, table: empty };
    return empty;
  }

  const table = {
    toArray: async () => {
      const tallies = await getWindowTalliesRows(windows);
      const wanted = uploadedSet;

      const byPep = d3.group(tallies.filter(r => wanted.has(String(r.peptide).toUpperCase())), r => r.peptide);
      const out = [];
      for (const [pep, arr] of byPep) {
        const frequency_all   = d3.sum(arr, r => +r.frequency_all);
        const frequency_unique= d3.sum(arr, r => +r.frequency_unique);
        const total_all       = arr[0]?.total_all ?? 0;
        const total_unique    = arr[0]?.total_unique ?? 0;
        out.push({
          protein            : proteinCommitted,
          peptide            : pep,
          frequency_all,
          total_all,
          proportion_all     : total_all ? (frequency_all / total_all) : 0,
          frequency_unique,
          total_unique,
          proportion_unique  : total_unique ? (frequency_unique / total_unique) : 0
        });
      }
      out.sort((a,b) => d3.descending(+a.proportion_all, +b.proportion_all) || a.peptide.localeCompare(b.peptide));
      return out;
    }
  };

  globalThis.__peptideCache = { key: filterKey, table };
  return table;
}
```


```js
/* Keeps the old name so downstream cells donâ€™t change */
const peptidePropsAll = getPeptidePropsAll();
```

```js
const histEl = histogramChart({
  data      : await (globalThis.__perfUtils?.perfAsync?.('sql: peptidePropsAll (histogram)', async () => await peptidePropsAll.toArray())),
  useUnique : seqSet === "Unique sequences"
})
```

```js
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   NetMHC-pan integration â€“ Class I & II
   - Appears *below* the existing dashboard cards for now
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

const statusBanner = html`<div style="margin:0.5rem 0; font-style:italic;"></div>`;
function setBanner(msg) { statusBanner.textContent = msg; }

/* â–¸ RUN buttons -------------------------------------------------- */
const runBtnI  = runButton("Run Class I (EL + BA)");
const runBtnII = runButton("Run Class II (EL + BA)");

// keep your existing reactive plumbing
const trigI  = Generators.input(runBtnI);
const trigII = Generators.input(runBtnII);

```

```js
// Snapshot `getValue()` right now and again every time `view` fires.
// No addEventListener anywhere â€” we rely purely on Generators.input(view).
function snapshotOn(view, getValue) {
  return Generators.observe(change => {
    const push = () => change(getValue());
    // initial snapshot
    push();
    // re-snapshot whenever the view emits
    (async () => {
      for await (const _ of Generators.input(view)) push();
    })();
    // no teardown necessary for Generators.input
    return () => {};
  });
}

```

```js
/* â–¸ state holders ------------------------------------------------ */
const resultsArrayI = Mutable([]);
const resultsArrayII = Mutable([]);

const excludedI = Mutable([]);      // peptides <8 or >14
const excludedII = Mutable([]);     // peptides <11 or >30
```

```js
/* â–¸ helpers to talk to IEDB -------------------------------------- */
function buildBodyI(alleles, fasta) {
  return {
    run_stage_range: [1,1],
    stages: [{
      stage_number: 1,
      stage_type  : "prediction",
      tool_group  : "mhci",
      input_sequence_text: fasta,
      input_parameters: {
        alleles: alleles.join(","),
        peptide_length_range: null,
        predictors: [
          {type:"binding", method:"netmhcpan_el"},
          {type:"binding", method:"netmhcpan_ba"}
        ]
      }
    }]
  };
}
function buildBodyII(alleles, fasta) {
  return {
    run_stage_range: [1,1],
    stages: [{
      stage_number: 1,
      stage_type  : "prediction",
      tool_group  : "mhcii",
      input_sequence_text: fasta,
      input_parameters: {
        alleles: alleles.join(","),
        peptide_length_range: null,
        predictors: [
          {type:"binding", method:"netmhciipan_el"},
          {type:"binding", method:"netmhciipan_ba"}
        ]
      }
    }]
  };
}
```

```js
async function submit(body) {
  const r = await fetch("/api/iedb-pipeline", {
    method:"POST",
    headers:{"content-type":"application/json"},
    body: JSON.stringify(body)
  });
  const txt = await r.text();
  const j   = (()=>{try{return JSON.parse(txt);}catch{return txt;}})();
  if (!r.ok) throw new Error(j.errors?.join("; ") || r.statusText);
  return j.results_uri.split("/").pop();       // result_id
}

async function poll(resultId, timeout = 90_000) {
  const t0 = Date.now();
  while (Date.now() - t0 < timeout) {
    const r = await fetch(`/api/iedb-result?id=${resultId}`);
    const txt = await r.text();
    const j   = (()=>{try{return JSON.parse(txt);}catch{return txt;}})();
    if (j.status === "done")
      return j.data?.results?.find(t => t.type === "peptide_table");
    await new Promise(res => setTimeout(res, 1000));
  }
  throw new Error("Timed out");
}

function rowsFromTable(tbl) {
  const keys = tbl.table_columns.map(c => c.display_name || c.name);
  return tbl.table_data.map(r => Object.fromEntries(r.map((v,i)=>[keys[i],v])));
}

/* â–¸ peptide-upload helper (re-uses existing peptideFile) ---------- */
async function parsePeptides(file) {
  if (!file) return [];
  const text = await file.text();
  const [hdr, ...lines] = text.trim().split(/\r?\n/);
  const cols = hdr.split(",").map(s => s.trim().toLowerCase());
  const idx  = cols.indexOf("peptide");
  if (idx < 0) return [];
  return lines
    .map(l => l.split(",")[idx]?.trim()?.toUpperCase())
    .filter(Boolean);
}

/* â–¸ parse uploaded peptide table with protein column ------------- */
async function parsePeptideTable(file) {
  if (!file) return [];
  const text = await file.text();
  const lines = text.trim().split(/\r?\n/);
  if (lines.length <= 1) return [];

  const headers = lines[0].split(",").map(s => s.trim());
  const lower   = headers.map(h => h.toLowerCase());
  const iPep    = lower.indexOf("peptide");
  const iProt   = lower.indexOf("protein");

  if (iPep < 0) return []; // must have peptide column

  const out = [];
  for (let i = 1; i < lines.length; i++) {
    const cols = lines[i].split(",");
    const pep  = cols[iPep]?.trim()?.toUpperCase();
    const prot = iProt >= 0 ? cols[iProt]?.trim() : null;
    if (pep) out.push({ peptide: pep, protein: prot });
  }
  return out;
}

```

```js
/* committed protein id â€” reactive */
function normalizeProteinId(v) {
  if (!v) return null;
  if (typeof v === "string") return v;
  if (typeof v === "object") return v.id ?? v.value ?? v.protein ?? null;
  return null;
}

const committedProteinId = (() => {
  const raw = proteinCommitted;        // â† establish reactive dependency
  const id  = normalizeProteinId(raw);
  const out = id ? String(id).trim().toUpperCase() : null;
  return out;
})();



```

```js
/* â”€â”€ Unified schema (snake_case) for Class I rows â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const keyMapI = {
  "peptide": "peptide",
  "allele": "allele",
  "netmhcpan_el percentile": "netmhcpan_el_percentile",
  "netmhcpan_ba percentile": "netmhcpan_ba_percentile"
};
// Cache rows already come in these 4 columns.
function normalizeRowI_cache(r) {
  return {
    allele: String(r.allele).toUpperCase(),    // keep HLA- prefix; pushdown uses exact match
    peptide: String(r.peptide).toUpperCase(),
    netmhcpan_el_percentile: +r.netmhcpan_el_percentile,  // already 2dp in slim file
    netmhcpan_ba_percentile: +r.netmhcpan_ba_percentile
  };
}

/* API table rows (display headers) â†’ only the 4 fields we keep */
function normalizeRowI_api(r) {
  return {
    allele: String(r["allele"] ?? r.allele).toUpperCase(),
    peptide: String(r["peptide"] ?? r.peptide).toUpperCase(),
    netmhcpan_el_percentile: +r["netmhcpan_el percentile"],
    netmhcpan_ba_percentile: +r["netmhcpan_ba percentile"]
  };
}

```

```js
const peptidesI = await (async () => {
  if (!peptideFile) return [];
  const all = await parsePeptides(peptideFile);
  return all.map(p => p.replace(/-/g,""))
            .filter(p => p.length >= 8 && p.length <= 14);
})();
```

```js
console.groupCollapsed("ðŸ”Ž Alt window lengths");
const winLens = peptideWindows.map(w => w.len);
console.log("Total windows:", winLens.length);
console.log("Len â‰¤7:",  winLens.filter(n => n<=7).length);
console.log("8â€“14:",   winLens.filter(n => n>=8 && n<=14).length);
console.log("â‰¥15:",    winLens.filter(n => n>=15).length);
console.groupEnd();

```

```js
/* Class I cache preview for the committed protein â€” uses WORKSET */
const cachePreviewI = await (async () => {
  selectedI;
  committedProteinId;

  const allelesRaw = Array.from(alleleCtrl1.value || []);   // e.g. "HLA-A*01:01"
  const pepsRaw    = peptidesIWorkset;

  if (!committedProteinId || !allelesRaw.length || !pepsRaw.length) return [];

  // No local cache; skip DB lookup
  const cacheRows = [];

  return cacheRows.map(normalizeRowI_cache);
})();

```

```js
/* merged rows for the chart â€” STRICT to workset */
const chartRowsI = (() => {
  selectedI;
  committedProteinId;

  const allelesNow = new Set((alleleCtrl1?.value || []).map(a => String(a).toUpperCase()));
  const allowed    = new Set((peptidesIWorkset || []).map(p => String(p).toUpperCase()));
  if (!allelesNow.size || !allowed.size) return [];

  const map = new Map();

  for (const r of cachePreviewI) {
    const al = String(r.allele || "").toUpperCase();
    const pp = String(r.peptide|| "").toUpperCase();
    if (allowed.has(pp) && allelesNow.has(al)) {
      map.set(`${al}|${pp}`, r);
    }
  }
  const apiRows = Array.isArray(runResultsI) ? runResultsI : [];
  for (const r of apiRows) {
    const al = String(r.allele || "").toUpperCase();
    const pp = String(r.peptide|| "").toUpperCase();
    if (allowed.has(pp) && allelesNow.has(al)) {
      map.set(`${al}|${pp}`, r);
    }
  }
  return [...map.values()];
})();

```

```js
/* ---- NetMHC batch size ---- */
const NETMHC_CHUNK_SIZE = 1000;   // was ~25 before; now 1000 as requested

```

```js
/* â–¸ RUN results â€“ Class I (per-protein workset; batch missing by 1000) */
const runResultsI = await (async () => {
  trigI;

  const allelesSel = Array.from(committedI || []);
  const pepsSel    = Array.from(committedWorksetI || []);

  if (!allelesSel.length) { setBanner("Class I: no alleles selected."); return []; }
  if (!pepsSel.length)    { setBanner("Class I: no peptides to run.");  return []; }

  setBanner(`Class I: checking cache for ${pepsSel.length} peptidesâ€¦`);

  // No local cache available
  const cacheRows = [];

  const normCache = cacheRows.map(normalizeRowI_cache);
  const cacheKey  = r => `${r.allele}|${r.peptide}`;
  const cacheSet  = new Set(normCache.map(cacheKey));

  const missingByAllele = new Map();
  for (const al of allelesSel) {
    const alU = String(al).toUpperCase();
    const miss = [];
    for (const p of pepsSel) {
      const pU = String(p).toUpperCase();
      if (!cacheSet.has(`${alU}|${pU}`)) miss.push(p);
    }
    if (miss.length) missingByAllele.set(al, miss);
  }

  if (missingByAllele.size === 0) {
    const merged = [...new Map(normCache.map(r => [cacheKey(r), r])).values()];
    resultsArrayI.value = merged;
    setBanner(`Class I: all ${merged.length} rows from cache âœ…`);
    return merged;
  }

  const allelesToQuery = [...missingByAllele.keys()];
  const unionMissing   = [...new Set([].concat(...allelesToQuery.map(al => missingByAllele.get(al))))];

  const chunks = [];
  for (let i = 0; i < unionMissing.length; i += NETMHC_CHUNK_SIZE) {
    chunks.push(unionMissing.slice(i, i + NETMHC_CHUNK_SIZE));
  }

  const apiRowsAll = [];
  for (let i = 0; i < chunks.length; i++) {
    const chunk = chunks[i];
    try {
      setBanner(`Class I: submitting chunk ${i+1}/${chunks.length} (${chunk.length} peptides)â€¦`);
      const fasta = chunk.map((p,idx)=>`>p${idx+1}\n${p}`).join("\n");

      const id  = await submit(buildBodyI(allelesToQuery, fasta));
      setBanner(`Class I: polling chunk ${i+1}/${chunks.length}â€¦`);
      const tbl = await poll(id);
      const apiRows = rowsFromTable(tbl);

      // Keep only the 4 columns + standardize case once
      for (const r of apiRows) {
        apiRowsAll.push(normalizeRowI_api(r));
      }

      await new Promise(res => setTimeout(res, 150));
    } catch (err) {
      console.error(`Chunk ${i+1} failed:`, err);
      setBanner(`Class I: chunk ${i+1} failed (${err.message}). Continuingâ€¦`);
      await new Promise(res => setTimeout(res, 250));
    }
  }

  // merge cache + API (API wins)
  const map = new Map();
  for (const r of normCache) map.set(`${r.allele}|${r.peptide}`, r);
  for (const r of apiRowsAll) map.set(`${r.allele}|${r.peptide}`, r);

  const merged = [...map.values()];
  resultsArrayI.value = merged;

  const uniqueApi = new Set(apiRowsAll.map(r => `${r.allele}|${r.peptide}`)).size;
  setBanner(`Class I done â€” ${merged.length} rows (cache ${cacheSet.size} + new ${uniqueApi}).`);
  return merged;
})();

```

```js
/* â–¸ RUN pipeline â€“ Class II -------------------------------------- */
trigII;                     // make cell reactive
(async () => {
  if (!peptideFile) return;
  setBanner("Class II: startingâ€¦");

  const alleles = Array.from(alleleCtrl2.value || []);  // Class II
  const allPeps = await parsePeptides(peptideFile);
  const okPeps  = allPeps.filter(p => p.length >= 11 && p.length <= 30);
  excludedII.value = allPeps.filter(p => p.length < 11 || p.length > 30);

  if (!alleles.length)  return setBanner("Class II: no alleles selected.");
  if (!okPeps.length)   return setBanner("Class II: no peptides in 11-30 range.");

  const fasta = okPeps.map((p,i)=>`>p${i+1}\n${p}`).join("\n");
  try {
    const id  = await submit(buildBodyII(alleles, fasta));
    setBanner("Class II: pollingâ€¦");
    const tbl = await poll(id);
    resultsArrayII.value = rowsFromTable(tbl);
    setBanner(`Class II done â€” ${resultsArrayII.value.length} rows.`);
  } catch (err) {
    setBanner(`Class II error: ${err.message}`);
  }
})();
```

```js
/* â–¸ CSV download helpers ----------------------------------------- */
function makeDownloadButton(label, rowsMut, filename) {
  const btn = Inputs.button(label);
  btn.onclick = () => {
    const rows = rowsMut.value;
    if (!rows.length) { alert(`No ${label.toLowerCase()} yet.`); return; }
    const cols = Object.keys(rows[0]);
    const csv  = [
      cols.join(","), ...rows.map(r => cols.map(c => r[c]).join(","))
    ].join("\n");
    const blob = new Blob([csv], {type:"text/csv"});
    const url  = URL.createObjectURL(blob);
    Object.assign(document.createElement("a"), {href:url, download:filename}).click();
    URL.revokeObjectURL(url);
  };
  return btn;
}

const downloadCSVI  = downloadButton({
  filename: "mhcI_predictions.csv",
  data    : () => resultsArrayI.value,
  tooltipTitle: "Download Class I predictions",
  tooltipBody : "netMHCpan EL/BA scores and percentiles for selected Class I alleles and peptide workset. Outputs as .csv"
});

const downloadCSVII = downloadButton({
  filename: "mhcII_predictions.csv",
  data    : () => resultsArrayII.value,
  tooltipTitle: "Download Class II predictions",
  tooltipBody : "netMHCIIpan EL/BA scores and percentiles for selected Class II alleles and uploaded peptides. Outputs as .csv"
});
```

```js
/* â–¸ uploaded peptides table + committed-protein slice (Class I) -- */
const uploadedPeptidesTable = await parsePeptideTable(peptideFile);


/* peptides for Class I, scoped to committed protein (reactive) */
const peptidesICommitted = (() => {
  const pid = committedProteinId;         // â† dependency
  if (!pid) return [];
  return peptidesClean
    .filter(r => (r.protein || "").toUpperCase() === pid)
    .map(r => (r.peptide || "").toUpperCase())
    .filter(p => p.length >= 8 && p.length <= 14);
})();



```








```js
/* external radios â€“ place these with your other controls */
const percentileModeInput = Inputs.radio(["EL","BA"], {
  label : "Percentile type:",
  value : "EL"
});
const mhcClassInput = Inputs.radio(["Class I","Class II"], {
  label : "MHC class:",
  value : "Class I"
});
const percMode = Generators.input(percentileModeInput);
const mhcClass = Generators.input(mhcClassInput);

/* allele plot â€” reactive to allele picks and Apply (protein) */
selectedI;
committedProteinId;

const allelePlot = alleleChart({
  data      : chartRowsI,
  alleles   : Array.from(alleleCtrl1.value || []),
  mode      : percentileModeInput,
  classType : "I",
  baseCell  : 28,
  margin    : { top: 40, right: 20, bottom: 20, left: 140 },
  showNumbers: false
});
```


```js
import {comboSelectLazy} from "./components/comboSelectLazy.js";

```

```js
/* HLA fetchers (on-demand from DuckDB) -------------------------- */
const PAGE_LIMIT_DEFAULT = 50;  // when searching (â‰¥2 chars)
const PAGE_LIMIT_INITIAL = 20;  // first display when q === ""

/* cls: "I" | "II"; q: string; offset/limit: paging */
async function fetchAlleles(cls, q = "", offset = 0, limit = PAGE_LIMIT_DEFAULT) {
  const clsNorm = (cls === "II" ? "II" : "I");

  if (!q || q.trim().length < 2) {
    // Initial list (no filter): fast DISTINCT over the pre-trimmed set
    const rows = await (globalThis.__perfUtils?.perfAsync?.(`sql: fetchAlleles initial ${clsNorm}`, async () => (await db.sql`
      WITH base AS (
        SELECT 'I'  AS class, TRIM("Class I")  AS allele FROM hla
        WHERE "Class I" IS NOT NULL AND LENGTH(TRIM("Class I")) > 0
        UNION ALL
        SELECT 'II' AS class, TRIM("Class II") AS allele FROM hla
        WHERE "Class II" IS NOT NULL AND LENGTH(TRIM("Class II")) > 0
      ),
      dedup AS (
        SELECT DISTINCT class, allele FROM base
      )
      SELECT allele
      FROM dedup
      WHERE class = ${clsNorm}
      ORDER BY allele
      LIMIT ${PAGE_LIMIT_INITIAL} OFFSET ${offset}
    `).toArray()))

    return rows.map(r => r.allele).filter(s => s && s.trim().length);
  }

  // Search path (q.length >= 2)
  const like = `%${q}%`;
  const rows = await (globalThis.__perfUtils?.perfAsync?.(`sql: fetchAlleles search ${clsNorm}`, async () => (await db.sql`
    WITH base AS (
      SELECT 'I'  AS class, TRIM("Class I")  AS allele FROM hla
      WHERE "Class I" IS NOT NULL AND LENGTH(TRIM("Class I")) > 0
      UNION ALL
      SELECT 'II' AS class, TRIM("Class II") AS allele FROM hla
      WHERE "Class II" IS NOT NULL AND LENGTH(TRIM("Class II")) > 0
    ),
    dedup AS (
      SELECT DISTINCT class, allele FROM base
    )
    SELECT allele
    FROM dedup
    WHERE class = ${clsNorm} AND allele ILIKE ${like}
    ORDER BY allele
    LIMIT ${limit} OFFSET ${offset}
  `).toArray()))

  return rows.map(r => r.allele).filter(s => s && s.trim().length);
}

```

```js
/* â–¸ allele lists (lazy) ----------------------------------------- */
const alleleCtrl1 = comboSelectLazy({
  label: "Class I alleles (MHCI)",
  placeholder: "Type class-I alleleâ€¦",
  fontFamily: "'Roboto', sans-serif",
  initialLimit: 20,
  pageLimit: 50,
  fetch: ({ q, offset, limit }) => fetchAlleles("I", q, offset, limit)
});
const selectedI = Generators.input(alleleCtrl1);

const alleleCtrl2 = comboSelectLazy({
  label: "Class II alleles (MHCII)",
  placeholder: "Type class-II alleleâ€¦",
  fontFamily: "'Roboto', sans-serif",
  initialLimit: 20,
  pageLimit: 50,
  fetch: ({ q, offset, limit }) => fetchAlleles("II", q, offset, limit)
});
const selectedII = Generators.input(alleleCtrl2);

/* snapshots captured only when the Run buttons fire */
const committedI        = snapshotOn(runBtnI,  () => Array.from(alleleCtrl1.value || []));
const committedWorksetI = snapshotOn(runBtnI,  () => Array.from(peptidesIWorkset || []));
const committedProteinI = snapshotOn(runBtnI,  () => committedProteinId);
const committedII       = snapshotOn(runBtnII, () => Array.from(alleleCtrl2.value || []));




```
